// server/services/ai-service.ts

import OpenAI from "openai";
import Anthropic from "@anthropic-ai/sdk";
import { storage } from "../storage";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { imageService } from "./image-service";
import { CloudinaryStorageService } from "./cloudinary-storage";
import { apiKeyEncryptionService } from "./api-key-encryption";

// Initialize Cloudinary storage
const cloudinaryStorage = new CloudinaryStorageService();

// AI Provider Configuration
export type AIProvider = "openai" | "anthropic" | "gemini";

// Model configurations
const AI_MODELS = {
  openai: {
    model: "gpt-4o",
    pricing: {
      input: 0.005,
      output: 0.015,
    },
  },
  anthropic: {
    model: process.env.ANTHROPIC_MODEL || "claude-sonnet-4-20250514",
    pricing: {
      input: 0.003,
      output: 0.015,
    },
  },
  gemini: {
    model: "gemini-1.5-flash-8b",
    pricing: {
      input: 0.0025,
      output: 0.0075,
    },
  },
} as const;

// Interface for user API keys from database
interface UserApiKey {
  id: string;
  provider: string;
  keyName: string;
  encryptedKey: string;
  isActive: boolean;
  validationStatus: 'valid' | 'invalid' | 'pending';
}

export interface ContentGenerationRequest {
  websiteId: string;
  topic: string;
  keywords: string[];
  tone: "professional" | "casual" | "friendly" | "authoritative" | "technical" | "warm";
  wordCount: number;
  seoOptimized: boolean;
  brandVoice?: string;
  targetAudience?: string;
  eatCompliance?: boolean;
  aiProvider: AIProvider;
  userId: string;
  includeImages?: boolean;
  imageCount?: number;
  imageStyle?: "natural" | "digital_art" | "photographic" | "cinematic";
  isAutoGenerated?: boolean;
  autoScheduleId?: string;
  autoPublish?: boolean;
  publishDelay?: number;
}

export interface ContentGenerationResultWithPublishing extends ContentGenerationResult {
  contentId?: string;
  published?: boolean;
  scheduledForPublishing?: boolean;
  publishedAt?: Date;
  scheduledDate?: Date;
  totalCost?: string;
  title?: string;
}

export interface ContentAnalysisRequest {
  title: string;
  content: string;
  keywords: string[];
  tone: string;
  brandVoice?: string;
  targetAudience?: string;
  eatCompliance?: boolean;
  websiteId: string;
  aiProvider: AIProvider;
  userId: string;
}

export interface ContentGenerationResult {
  title: string;
  content: string;
  excerpt: string;
  metaDescription: string;
  metaTitle: string;
  keywords: string[];
  seoScore: number;
  readabilityScore: number;
  brandVoiceScore: number;
  eatCompliance: boolean;
  tokensUsed: number;
  costUsd: number;
  aiProvider: AIProvider;
  qualityChecks: {
    plagiarismRisk: "low" | "medium" | "high";
    factualAccuracy: "verified" | "needs_review" | "questionable";
    brandAlignment: "excellent" | "good" | "needs_improvement";
  };
  images?: Array<{
    url: string;
    filename: string;
    altText: string;
    prompt: string;
    cost: number;
    cloudinaryUrl?: string;
    cloudinaryPublicId?: string;
  }>;
  totalImageCost?: number;
}

export interface ContentAnalysisResult {
  seoScore: number;
  readabilityScore: number;
  brandVoiceScore: number;
  tokensUsed: number;
  costUsd: number;
  aiProvider: AIProvider;
}

// Custom error classes
export class AIProviderError extends Error {
  constructor(provider: AIProvider, message: string) {
    super(`${provider.toUpperCase()} Error: ${message}`);
    this.name = "AIProviderError";
  }
}

export class AnalysisError extends Error {
  constructor(analysisType: string, message: string) {
    super(`${analysisType} Analysis Error: ${message}`);
    this.name = "AnalysisError";
  }
}

export class ContentFormatter {
  static convertMarkdownToHtml(content: string): string {
    return content
      .replace(/^######\s+(.+)$/gm, "<h6>$1</h6>")
      .replace(/^#####\s+(.+)$/gm, "<h5>$1</h5>")
      .replace(/^####\s+(.+)$/gm, "<h4>$1</h4>")
      .replace(/^###\s+(.+)$/gm, "<h3>$1</h3>")
      .replace(/^##\s+(.+)$/gm, "<h2>$1</h2>")
      .replace(/^#\s+(.+)$/gm, "<h1>$1</h1>")
      .replace(/^######\s+(.+?)\s*$/gm, "<h6>$1</h6>")
      .replace(/^#####\s+(.+?)\s*$/gm, "<h5>$1</h5>")
      .replace(/^####\s+(.+?)\s*$/gm, "<h4>$1</h4>")
      .replace(/^###\s+(.+?)\s*$/gm, "<h3>$1</h3>")
      .replace(/^##\s+(.+?)\s*$/gm, "<h2>$1</h2>")
      .replace(/^#\s+(.+?)\s*$/gm, "<h1>$1</h1>");
  }

  static convertMarkdownFormatting(content: string): string {
    return content
      .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
      .replace(/__(.*?)__/g, "<strong>$1</strong>")
      .replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, "<em>$1</em>")
      .replace(/(?<!_)_([^_]+?)_(?!_)/g, "<em>$1</em>")
      .replace(/^[\-\‚Ä¢\‚óÜ\*\+]\s+(.+)$/gm, "<li>$1</li>")
      .replace(/^\d+\.\s+(.+)$/gm, "<li>$1</li>");
  }

  static wrapListItems(content: string): string {
    content = content.replace(
      /(<li>.*?<\/li>(?:\s*<li>.*?<\/li>)*)/gs,
      (match) => {
        if (match.includes("<li>")) {
          return `<ul>\n${match}\n</ul>`;
        }
        return match;
      }
    );
    return content;
  }

  static formatForWordPress(content: string): string {
    let formatted = content;
    formatted = this.convertMarkdownToHtml(content);
    formatted = this.convertMarkdownFormatting(formatted);
    formatted = this.wrapListItems(formatted);
    formatted = this.addParagraphTags(formatted);
    formatted = this.addHeaderSpacing(formatted);
    formatted = this.addProperSpacing(formatted);
    return formatted;
  }

  private static addParagraphTags(content: string): string {
    const blocks = content.split("\n\n");
    return blocks
      .map((block) => {
        const trimmed = block.trim();
        if (!trimmed) return "";
        if (trimmed.startsWith("<") && trimmed.endsWith(">")) {
          return trimmed;
        }
        if (trimmed.match(/^<h[1-6]>/)) {
          return trimmed;
        }
        return `<p>${trimmed}</p>`;
      })
      .join("\n\n");
  }

  private static addProperSpacing(content: string): string {
    return content
      .replace(/(<h[1-6]>.*?<\/h[1-6]>)/g, "\n$1\n")
      .replace(/(<\/?(?:ul|ol)>)/g, "\n$1\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
  }

  private static addHeaderSpacing(content: string): string {
    return content
      .replace(/(<h[1-6]>.*?<\/h[1-6]>)/g, "\n$1\n")
      .replace(/\n{3,}/g, "\n\n");
  }
}

export class AIService {
  // Cache for API keys to avoid repeated database queries
  private apiKeyCache: Map<string, { key: string; type: 'user' | 'system'; timestamp: number }> = new Map();
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

  /**
   * Get the API key for a provider, checking user's keys first, then falling back to env vars
   */
private async getApiKey(provider: AIProvider, userId: string): Promise<{ key: string; type: 'user' | 'system' } | null> {
  const cacheKey = `${userId}-${provider}`;
  
  console.log(`üîç DEBUG getApiKey called:`, { provider, userId, cacheKey });
  
  // Check cache first
  const cached = this.apiKeyCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
    console.log(`‚úÖ Using cached API key for ${provider}`);
    // Need to determine if this cached key is user or system
    // We'll need to update the cache structure to store this info
    return { key: cached.key, type: cached.type };
  }

  try {
    // Try to get user's API key first
    const userApiKeys = await storage.getUserApiKeys(userId);
    
    if (userApiKeys && userApiKeys.length > 0) {
      const providerMap: Record<AIProvider, string> = {
        'openai': 'openai',
        'anthropic': 'anthropic',
        'gemini': 'gemini'
      };

      const dbProvider = providerMap[provider];
      const validKey = userApiKeys.find(
        (key: any) => 
          key.provider === dbProvider && 
          key.isActive && 
          key.validationStatus === 'valid'
      );

      if (validKey && validKey.encryptedApiKey) {
        try {
          const decryptedKey = apiKeyEncryptionService.decrypt(validKey.encryptedApiKey);
          
          // Cache with type information
          this.apiKeyCache.set(cacheKey, {
            key: decryptedKey,
            type: 'user',
            timestamp: Date.now()
          });

          console.log(`‚úÖ Using user's API key for ${provider} (${validKey.keyName})`);
          return { key: decryptedKey, type: 'user' };
        } catch (decryptError: any) {
          console.error(`Failed to decrypt user's ${provider} key:`, decryptError.message);
        }
      }
    }
  } catch (error: any) {
    console.warn(`Failed to fetch user's API keys: ${error.message}`);
  }

  // Fallback to environment variables (system keys)
  console.log(`‚ö†Ô∏è No user API key found for ${provider}, falling back to environment variables`);
  
  let systemKey: string | null = null;
  switch (provider) {
    case 'openai':
      systemKey = process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY_ENV_VAR || null;
      break;
    case 'anthropic':
      systemKey = process.env.ANTHROPIC_API_KEY || null;
      break;
    case 'gemini':
      systemKey = process.env.GOOGLE_GEMINI_API_KEY || null;
      break;
  }

  if (systemKey) {
    // Cache system key with type
    this.apiKeyCache.set(cacheKey, {
      key: systemKey,
      type: 'system',
      timestamp: Date.now()
    });
    return { key: systemKey, type: 'system' };
  }

  return null;
}
  /**
   * Create an OpenAI client with the appropriate API key
   */
private async createOpenAIClient(userId: string): Promise<{ client: OpenAI; keyType: 'user' | 'system' }> {
  const keyInfo = await this.getApiKey('openai', userId);
  
  if (!keyInfo) {
    throw new AIProviderError('openai', 'No API key available. Please add your OpenAI API key in settings or contact support.');
  }

  return {
    client: new OpenAI({ apiKey: keyInfo.key }),
    keyType: keyInfo.type
  };
}

private async createAnthropicClient(userId: string): Promise<{ client: Anthropic; keyType: 'user' | 'system' }> {
  const keyInfo = await this.getApiKey('anthropic', userId);
  
  if (!keyInfo) {
    throw new AIProviderError('anthropic', 'No API key available. Please add your Anthropic API key in settings or contact support.');
  }

  return {
    client: new Anthropic({ apiKey: keyInfo.key }),
    keyType: keyInfo.type
  };
}

private async createGeminiClient(userId: string): Promise<{ client: GoogleGenerativeAI; keyType: 'user' | 'system' }> {
  const keyInfo = await this.getApiKey('gemini', userId);
  
  if (!keyInfo) {
    throw new AIProviderError('gemini', 'No API key available. Please add your Google Gemini API key in settings or contact support.');
  }

  return {
    client: new GoogleGenerativeAI(keyInfo.key),
    keyType: keyInfo.type
  };
}
  /**
   * Clear cached API key for a user (call this when user updates their keys)
   */
  public clearApiKeyCache(userId: string, provider?: AIProvider): void {
    if (provider) {
      this.apiKeyCache.delete(`${userId}-${provider}`);
    } else {
      // Clear all keys for the user
      for (const key of this.apiKeyCache.keys()) {
        if (key.startsWith(`${userId}-`)) {
          this.apiKeyCache.delete(key);
        }
      }
    }
     console.log(`üîÑ Cleared API key cache for user ${userId}${provider ? ` (${provider})` : ' (all providers)'}`);
  }

  public async callOpenAI(
  messages: any[],
  responseFormat?: any,
  temperature = 0.7,
  userId?: string
): Promise<{ content: string; tokens: number; keyType?: 'user' | 'system' }> {
  let keyType: 'user' | 'system' = 'system';
  
  try {
    let openai: OpenAI;
    
    if (userId) {
      const clientInfo = await this.createOpenAIClient(userId);
      openai = clientInfo.client;
      keyType = clientInfo.keyType;
    } else {
      // Backwards compatibility - use env vars directly
      openai = new OpenAI({ 
        apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_API_KEY_ENV_VAR 
      });
      keyType = 'system';
    }

    const response = await openai.chat.completions.create({
      model: AI_MODELS.openai.model,
      messages,
      response_format: responseFormat,
      temperature,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new AIProviderError("openai", "No content returned from API");
    }

    return {
      content,
      tokens: response.usage?.total_tokens || 0,
      keyType
    };
  } catch (error: any) {
      if (error instanceof AIProviderError) throw error;

      if (error.status === 401) {
        // Clear cache on auth error
        if (userId) this.clearApiKeyCache(userId, 'openai');
        throw new AIProviderError(
          "openai",
          "Invalid API key. Please check your OpenAI API key in settings."
        );
      } else if (error.status === 429) {
        throw new AIProviderError("openai", "Rate limit exceeded. Please try again later.");
      } else if (error.status === 403) {
        throw new AIProviderError(
          "openai",
          "Insufficient permissions. Please check your OpenAI API key permissions."
        );
      }

      throw new AIProviderError("openai", error.message || "Unknown API error");
    }
  }

  private async callGemini(
  messages: any[],
  temperature = 0.7,
  userId?: string
): Promise<{ content: string; tokens: number; keyType?: 'user' | 'system' }> {
  let keyType: 'user' | 'system' = 'system';
  
  try {
    let gemini: GoogleGenerativeAI;
    
    if (userId) {
      // Get the API key with type information
      const keyInfo = await this.getApiKey('gemini', userId);
      
      if (!keyInfo) {
        throw new AIProviderError("gemini", "No API key available. Please add your Google API key in settings.");
      }
      
      // Create the Gemini client with the key
      gemini = new GoogleGenerativeAI(keyInfo.key);
      keyType = keyInfo.type;
      
      console.log(`‚úÖ Created Gemini client with ${keyType} key`);
    } else {
      // Fallback to environment variable
      const envKey = process.env.GOOGLE_GEMINI_API_KEY;
      
      if (!envKey) {
        throw new AIProviderError("gemini", "No Google API key available in environment.");
      }
      
      gemini = new GoogleGenerativeAI(envKey);
      keyType = 'system';
    }

    // Rest of the Gemini implementation...
    const model = gemini.getGenerativeModel({
      model: AI_MODELS.gemini.model,
    });

      const systemMessage = messages.find((m) => m.role === "system");
      const userMessages = messages.filter((m) => m.role === "user" || m.role === "assistant");

      const history = userMessages.slice(0, -1).map((m) => ({
        role: m.role === "user" ? "user" : "model",
        parts: [{ text: m.content }],
      }));

      const lastMessage = userMessages[userMessages.length - 1];
      if (!lastMessage || lastMessage.role !== "user") {
        throw new AIProviderError(
          "gemini",
          "Invalid message format - last message must be from user"
        );
      }

      const chat = model.startChat({
        history,
        generationConfig: {
          temperature,
          maxOutputTokens: 4000,
        },
      });

      let prompt = lastMessage.content;
      if (systemMessage?.content) {
        prompt = `${systemMessage.content}\n\n${prompt}`;

        if (systemMessage.content.includes("JSON") || systemMessage.content.includes("json")) {
          prompt +=
            "\n\nIMPORTANT: You must respond with valid JSON only. Do not include any text before or after the JSON object. Start your response with { and end with }.";
        }
      }

      const result = await chat.sendMessage(prompt);
      const response = await result.response;
      const responseText = response.text();

      if (!responseText) {
        throw new AIProviderError("gemini", "No content returned from API");
      }

      let cleanedText = responseText.trim();

      if (!cleanedText.startsWith("{") && cleanedText.includes("{")) {
        const jsonStart = cleanedText.indexOf("{");
        const jsonEnd = cleanedText.lastIndexOf("}") + 1;
        if (jsonStart !== -1 && jsonEnd > jsonStart) {
          cleanedText = cleanedText.substring(jsonStart, jsonEnd);
        }
      }

      const estimatedTokens = Math.ceil((prompt.length + cleanedText.length) / 4);

      return {
        content: cleanedText,
        tokens: estimatedTokens,
      };
    } catch (error: any) {
      if (error instanceof AIProviderError) throw error;

      if (error.status === 429 || error.message?.includes("Too Many Requests")) {
        throw new AIProviderError(
          "gemini",
          "Rate limit exceeded. Google Gemini free tier allows only 15 requests/minute and 1,500/day. " +
            "Please wait a few minutes or consider upgrading to a paid plan. " +
            "Alternatively, use OpenAI or Anthropic for now."
        );
      } else if (error.message?.includes("API_KEY_INVALID")) {
        if (userId) this.clearApiKeyCache(userId, 'gemini');
        throw new AIProviderError(
          "gemini",
          "Invalid API key. Please check your Google API key in settings."
        );
      }

      throw new AIProviderError("gemini", error.message || "Unknown API error");
    }
  }

  

  private async callAnthropic(
  messages: any[],
  temperature = 0.7,
  userId?: string
): Promise<{ content: string; tokens: number; keyType?: 'user' | 'system' }> {
  let keyType: 'user' | 'system' = 'system';
  
  try {
    let anthropic: Anthropic;
    
    if (userId) {
      // Get the API key with type information
      const keyInfo = await this.getApiKey('anthropic', userId);
      
      if (!keyInfo) {
        throw new AIProviderError("anthropic", "No API key available. Please add your Anthropic API key in settings.");
      }
      
      // Create the Anthropic client with the key
      anthropic = new Anthropic({ apiKey: keyInfo.key });
      keyType = keyInfo.type;
      
      console.log(`‚úÖ Created Anthropic client with ${keyType} key`);
    } else {
      // Fallback to environment variable
      const envKey = process.env.ANTHROPIC_API_KEY;
      
      if (!envKey) {
        throw new AIProviderError("anthropic", "No Anthropic API key available in environment.");
      }
      
      anthropic = new Anthropic({ apiKey: envKey });
      keyType = 'system';
    }

    // Now anthropic should be properly initialized
    const systemMessage = messages.find((m) => m.role === "system");
    const userMessages = messages.filter((m) => m.role === "user" || m.role === "assistant");

    let systemContent = systemMessage?.content || "";
    if (systemContent.includes("JSON") || systemContent.includes("json")) {
      systemContent +=
        "\n\nIMPORTANT: You must respond with valid JSON only. Do not include any text before or after the JSON object. Start your response with { and end with }.";
    }

    const response = await anthropic.messages.create({
      model: AI_MODELS.anthropic.model,
      max_tokens: 4000,
      temperature,
      system: systemContent,
      messages: userMessages.map((m) => ({
        role: m.role === "user" ? "user" : "assistant",
        content: m.content,
      })),
    });

    const content = response.content[0];
    if (content.type !== "text" || !content.text) {
      throw new AIProviderError("anthropic", "No text content returned from API");
    }

    let responseText = content.text.trim();

    // Clean up JSON response if needed
    if (!responseText.startsWith("{") && responseText.includes("{")) {
      const jsonStart = responseText.indexOf("{");
      const jsonEnd = responseText.lastIndexOf("}") + 1;
      if (jsonStart !== -1 && jsonEnd > jsonStart) {
        responseText = responseText.substring(jsonStart, jsonEnd);
      }
    }

    return {
      content: responseText,
      tokens: response.usage.input_tokens + response.usage.output_tokens,
      keyType
    };
    
  } catch (error: any) {
    if (error instanceof AIProviderError) throw error;

    if (error.status === 401) {
      if (userId) this.clearApiKeyCache(userId, 'anthropic');
      throw new AIProviderError(
        "anthropic",
        "Invalid API key. Please check your Anthropic API key in settings."
      );
    } else if (error.status === 429) {
      throw new AIProviderError("anthropic", "Rate limit exceeded. Please try again later.");
    }

    throw new AIProviderError("anthropic", error.message || "Unknown API error");
  }
}

  private async callAI(
    provider: AIProvider,
    messages: any[],
    responseFormat?: any,
    temperature = 0.7,
    userId?: string
  ): Promise<{ content: string; tokens: number; keyType?: 'user' | 'system' }> {
    switch (provider) {
      case "openai":
        return this.callOpenAI(messages, responseFormat, temperature, userId);
      case "anthropic":
        return this.callAnthropic(messages, temperature, userId);
      case "gemini":
        return this.callGemini(messages, temperature, userId);
      default:
        throw new Error(`Unsupported AI provider: ${provider}`);
    }
  }

  public embedImagesInContent(
    content: string,
    images: Array<{
      url: string;
      filename: string;
      altText: string;
      prompt: string;
      cost: number;
    }>
  ): string {
    return this.embedImagesInContentPrivate(content, images);
  }

  private embedImagesInContentPrivate(
    content: string,
    images: Array<{
      url: string;
      filename: string;
      altText: string;
      prompt: string;
      cost: number;
      cloudinaryUrl?: string;
    }>
  ): string {
    if (!images || images.length === 0) {
      return content;
    }

    let modifiedContent = content;

    images.forEach((image, index) => {
      // Use Cloudinary URL if available, otherwise fallback to original URL
      const imageUrl = image.cloudinaryUrl || image.url;
      
      const imageHtml = `
<figure class="wp-block-image size-large">
  <img src="${imageUrl}" alt="${image.altText}" class="wp-image" style="max-width: 100%; height: auto;" />
  <figcaption>${image.altText}</figcaption>
</figure>
`;

      if (index === 0) {
        const firstParagraphEnd = modifiedContent.indexOf("</p>");
        if (firstParagraphEnd !== -1) {
          modifiedContent =
            modifiedContent.slice(0, firstParagraphEnd + 4) +
            "\n\n" +
            imageHtml +
            "\n\n" +
            modifiedContent.slice(firstParagraphEnd + 4);
          console.log(`üñºÔ∏è Placed hero image after introduction`);
        } else {
          modifiedContent = imageHtml + "\n\n" + modifiedContent;
          console.log(`üñºÔ∏è Placed hero image at beginning (fallback)`);
        }
      } else {
        const h2Regex = /<h2>/g;
        const h2Matches = Array.from(modifiedContent.matchAll(h2Regex));

        if (h2Matches.length > index - 1) {
          const insertPoint = h2Matches[index - 1].index;
          modifiedContent =
            modifiedContent.slice(0, insertPoint) +
            imageHtml +
            "\n\n" +
            modifiedContent.slice(insertPoint);
          console.log(`üñºÔ∏è Placed image ${index + 1} before H2 section`);
        } else {
          const conclusionHeadings = ["<h2>Conclusion", "<h2>Summary", "<h2>Final"];
          let insertPoint = -1;

          for (const heading of conclusionHeadings) {
            insertPoint = modifiedContent.lastIndexOf(heading);
            if (insertPoint !== -1) break;
          }

          if (insertPoint !== -1) {
            modifiedContent =
              modifiedContent.slice(0, insertPoint) +
              imageHtml +
              "\n\n" +
              modifiedContent.slice(insertPoint);
            console.log(`üñºÔ∏è Placed image ${index + 1} before conclusion`);
          } else {
            modifiedContent = modifiedContent + "\n\n" + imageHtml;
            console.log(`üñºÔ∏è Placed image ${index + 1} at end (fallback)`);
          }
        }
      }
    });

    return modifiedContent;
  }

  async analyzeExistingContent(request: {
    title: string;
    content: string;
    keywords: string[];
    tone: string;
    brandVoice?: string;
    targetAudience?: string;
    eatCompliance?: boolean;
    websiteId: string;
    aiProvider: AIProvider;
    userId: string;
  }): Promise<ContentAnalysisResult> {
    try {
      console.log(`Re-analyzing existing content with ${request.aiProvider.toUpperCase()}`);

      const analysisResult = await this.performContentAnalysis({
        title: request.title,
        content: request.content,
        keywords: request.keywords,
        tone: request.tone,
        brandVoice: request.brandVoice,
        targetAudience: request.targetAudience,
        eatCompliance: request.eatCompliance || false,
        websiteId: request.websiteId,
        aiProvider: request.aiProvider,
        userId: request.userId,
      });

      console.log(
        `‚úÖ Existing content re-analyzed - SEO: ${analysisResult.seoScore}%, Readability: ${analysisResult.readabilityScore}%, Brand Voice: ${analysisResult.brandVoiceScore}%`
      );

      return analysisResult;
    } catch (error: any) {
      console.error("Failed to analyze existing content:", error);
      if (error instanceof AIProviderError || error instanceof AnalysisError) {
        throw error;
      }
      throw new AnalysisError(
        "Content Re-analysis",
        error.message || "Unknown error during content analysis"
      );
    }
  }

  async generateContent(
    request: ContentGenerationRequest
  ): Promise<ContentGenerationResultWithPublishing> {
    try {
      console.log(
        `Generating content for user ${request.userId} with ${request.aiProvider.toUpperCase()}`
      );

      if (request.isAutoGenerated) {
        console.log(`Auto-generation detected:`, {
          autoScheduleId: request.autoScheduleId,
          autoPublish: request.autoPublish,
          publishDelay: request.publishDelay,
        });
      }

      // Step 1: Check if image generation is requested
      if (request.includeImages && request.imageCount && request.imageCount > 0) {
        // Check if user has OpenAI key for image generation
        const openAiKey = await this.getApiKey('openai', request.userId);
        if (!openAiKey) {
          console.warn("‚ö†Ô∏è Image generation requested but no OpenAI API key available");
          request.includeImages = false;
          request.imageCount = 0;
        } else {
          console.log(
            `üé® Will generate ${request.imageCount} images with DALL-E 3 (regardless of content AI provider: ${request.aiProvider})`
          );
        }
      }

      // Step 2: Generate the actual content
      const contentPrompt = this.buildContentPrompt(request);

      const systemPrompt = `Okay, real talk. You're that friend who actually knows their shit about ${request.topic} because you've been in the trenches for years. Not the guru type‚Äîthe person who's failed enough times to know what actually works.

Write like you're explaining this to someone smart who just asked you for the real story. They don't need the Wikipedia version. They need the "here's what nobody tells you" version.

=== YOUR VOICE CALIBRATION ===
You're not writing. You're talking. Big difference.
- Interrupt yourself when you realize something: "Actually, wait‚Äîbefore I explain that..."
- Correct yourself: "No, that's not quite right. What I mean is..."
- Show uncertainty: "I think it's around 73%? Maybe 74%. Let me explain why that matters..."
- Get excited about the interesting parts: "Oh, and this part is actually super interesting..."
- Brief tangents that loop back: "Reminds me of when... but anyway, back to the point"

=== CRITICAL ANTI-PATTERN RULES ===
NEVER use these (they scream AI):
- Starting with "In today's..." or "In the world of..." or "In this article..."
- Transitions: Moreover, Furthermore, Additionally, In conclusion
- Perfect 3-4 sentence paragraphs
- Three-item lists (vary between 2, 4, 6, 7 items)
- Generic examples‚Äîuse specific companies, exact dates, real prices

ALWAYS do this:
- Use fragments. Like this. For emphasis.
- Mix 3-word sentences with 47-word rambles that include tangents (like that time in March 2024 when everyone thought X would work but it completely backfired because nobody considered Y)
- Specific numbers: "increased conversions by 37.4%" not "significantly improved"
- Real timestamps: "Last Tuesday at 2:47pm" not "recently"
- Actual tools with versions: "WordPress 6.4.2" not "content management systems"
- Include at least one failure: "Tried X first. Cost me $3,400. Here's why it failed..."

=== STRUCTURE CHAOS PROTOCOL ===
Don't follow a template. Let the content flow naturally:
- Jump straight into the most interesting/controversial point
- Circle back to explain context when needed
- Mix ultra-tactical advice with broader observations
- Include "Oh, I should mention..." additions
- Leave some questions hanging before answering them later

Return JSON but write the content field like you're having a conversation. Include HTML tags for structure but keep the voice conversational and slightly chaotic.`;

      const contentResponse = await this.callAI(
        request.aiProvider,
        [
          { role: "system", content: systemPrompt },
          { role: "user", content: contentPrompt },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.7,
        request.userId  // Pass userId for API key lookup
      );

      const keyTypeUsed = contentResponse.keyType || 'system';

      let contentResult;
      try {
        let cleanedContent = contentResponse.content.trim();
        cleanedContent = cleanedContent.replace(/^\uFEFF/, "");
        contentResult = JSON.parse(cleanedContent);
        console.log("‚úÖ Successfully parsed JSON response from", request.aiProvider.toUpperCase());
      } catch (parseError: any) {
        console.error("‚ùå Initial JSON parse failed, attempting extraction...", parseError.message);

        let cleanedContent = contentResponse.content.trim();
        const firstBrace = cleanedContent.indexOf("{");
        const lastBrace = cleanedContent.lastIndexOf("}");

        if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
          const extractedJson = cleanedContent.substring(firstBrace, lastBrace + 1);

          try {
            contentResult = JSON.parse(extractedJson);
            console.log("‚úÖ Successfully parsed extracted JSON from", request.aiProvider.toUpperCase());
          } catch (secondParseError: any) {
            throw new AIProviderError(
              request.aiProvider,
              `Failed to parse JSON response after multiple attempts. Original error: ${parseError.message}`
            );
          }
        } else {
          throw new AIProviderError(
            request.aiProvider,
            `No valid JSON structure found in response. Response was: ${contentResponse.content.substring(
              0,
              300
            )}...`
          );
        }
      }

      if (!contentResult.title || !contentResult.content) {
        throw new AIProviderError(
          request.aiProvider,
          "AI response missing required fields (title, content)"
        );
      }

      // Convert markdown headers to HTML if they exist
      console.log("üîÑ Converting markdown headers to HTML...");

      if (contentResult.content && contentResult.content.includes("#")) {
        console.log("üîç Markdown headers detected, converting to HTML...");
        contentResult.content = ContentFormatter.convertMarkdownToHtml(contentResult.content);
      }

      contentResult.content = ContentFormatter.formatForWordPress(contentResult.content);
      console.log("‚úÖ Content formatted for WordPress");

      // Pre-generate contentId for image storage (temporary, will be replaced)
      let contentId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      // Step 3: Generate images if requested (ALWAYS using OpenAI DALL-E 3)
      let images: Array<{
        url: string;
        filename: string;
        altText: string;
        prompt: string;
        cost: number;
        cloudinaryUrl?: string;
        cloudinaryPublicId?: string;
      }> = [];
      let totalImageCost = 0;
      let imageKeyType: 'user' | 'system' = 'system';

      if (request.includeImages && request.imageCount && request.imageCount > 0) {
        try {
          console.log(
            `üé® Generating ${request.imageCount} images with DALL-E 3 (content generated with ${request.aiProvider.toUpperCase()})...`
          );

          const imageGenerationRequest = {
            topic: request.topic,
            count: request.imageCount,
            style: request.imageStyle || "natural",
            contentContext: contentResult.content.substring(0, 500),
            keywords: request.keywords,
          };

          const validation = imageService.validateImageRequest(imageGenerationRequest);
          if (!validation.valid) {
            throw new Error(
              `Image generation validation failed: ${validation.errors.join(", ")}`
            );
          }

          // Pass userId to imageService for API key lookup
           const imageResult = await imageService.generateImages(
      imageGenerationRequest, 
      request.userId,  // <-- Pass userId here!
      request.websiteId
    );

    imageKeyType = imageResult.keyType || 'system';

          // CRITICAL: Upload to Cloudinary immediately after generation
          console.log(`‚òÅÔ∏è Uploading images to Cloudinary for permanent storage...`);
          
          for (const img of imageResult.images) {
            try {
              // Upload directly from DALL-E URL to Cloudinary
              const cloudinaryImage = await cloudinaryStorage.uploadFromUrl(
                img.url, // DALL-E temporary URL
                request.websiteId,
                contentId,
                img.filename
              );

              // Store both URLs - Cloudinary is permanent, DALL-E is temporary
              images.push({
                ...img,
                url: cloudinaryImage.secureUrl, // Use Cloudinary URL in content
                cloudinaryUrl: cloudinaryImage.secureUrl,
                cloudinaryPublicId: cloudinaryImage.publicId,
              });

              console.log(`‚úÖ Image permanently stored in Cloudinary: ${img.filename}`);
            } catch (uploadError: any) {
              console.error(`‚ùå Failed to upload to Cloudinary: ${img.filename}`, uploadError.message);
              // Still include the image but with temporary DALL-E URL (will expire!)
              images.push(img);
            }
          }

          totalImageCost = imageResult.totalCost;
          console.log(
            `‚úÖ Generated ${images.length} images with DALL-E 3 (Total cost: $${totalImageCost.toFixed(
              4
            )})`
          );

          if (images.length > 0) {
            console.log("üñºÔ∏è Embedding Cloudinary images into content...");
            contentResult.content = this.embedImagesInContentPrivate(
              contentResult.content,
              images
            );
            console.log(`‚úÖ Embedded ${images.length} images into content`);
          }
        } catch (imageError: any) {
          console.error("‚ùå Image generation failed:", imageError.message);

          if (imageError.message.includes("Rate limit")) {
            console.warn("‚ö†Ô∏è DALL-E rate limit reached, continuing without images");
          } else if (
            imageError.message.includes("credits") ||
            imageError.message.includes("quota")
          ) {
            console.warn("‚ö†Ô∏è Insufficient OpenAI credits for images, continuing without images");
          } else if (imageError.message.includes("API key")) {
            console.warn("‚ö†Ô∏è OpenAI API key issue for image generation, continuing without images");
          } else {
            console.warn(`‚ö†Ô∏è Image generation error: ${imageError.message}`);
          }

          images = [];
          totalImageCost = 0;
        }
      }

      // Step 4: Analyze the generated content
      const analysisResult = await this.performContentAnalysis({
        title: contentResult.title,
        content: contentResult.content,
        keywords: request.keywords,
        tone: request.tone,
        brandVoice: request.brandVoice,
        targetAudience: request.targetAudience,
        eatCompliance: request.eatCompliance,
        websiteId: request.websiteId,
        aiProvider: request.aiProvider,
        userId: request.userId,
      });

      // Step 5: Calculate total costs
      const contentTokens = Math.max(1, contentResponse.tokens + analysisResult.tokensUsed);
      const contentPricing = AI_MODELS[request.aiProvider].pricing;
      const avgTokenCost = (contentPricing.input + contentPricing.output) / 2;
      const textCostUsd = (contentTokens * avgTokenCost) / 1000;
      const totalCostUsd = textCostUsd + totalImageCost;

      console.log(`üí∞ Cost breakdown:`);
      console.log(
        `   Content (${request.aiProvider.toUpperCase()}): $${textCostUsd.toFixed(
          6
        )} (${contentTokens} tokens)`
      );
      console.log(`   Images (DALL-E 3): $${totalImageCost.toFixed(6)}`);
      console.log(`   Total: $${totalCostUsd.toFixed(6)}`);

      // Step 6: Track AI usage
      try {
        await storage.trackAiUsage({
          websiteId: request.websiteId,
          userId: request.userId,
          model: AI_MODELS[request.aiProvider].model,
          tokensUsed: contentTokens,
          costUsd: Math.max(1, Math.round(textCostUsd * 100)),
          operation: "content_generation",
          keyType: keyTypeUsed
        });

        if (images.length > 0) {
          await storage.trackAiUsage({
            websiteId: request.websiteId,
            userId: request.userId,
            model: "dall-e-3",
            tokensUsed: 0,
            costUsd: Math.round(totalImageCost * 100),
            operation: "image_generation",
            keyType: imageKeyType
          });
        }
      } catch (trackingError: any) {
        console.warn("AI usage tracking failed:", trackingError.message);
      }

      // Step 7: Generate quality checks
      const qualityChecks = this.generateQualityChecks(contentResult.content, request);

      // Step 8: Save generated content to database and handle scheduling
      let savedContentId: string | undefined;
      let published = false;
      let scheduledForPublishing = false;
      let publishedAt: Date | undefined;
      let scheduledDate: Date | undefined;

      try {
        // Prepare content data for database using the existing createContent method
        const contentToSave = {
          websiteId: request.websiteId,
          userId: request.userId,
          title: contentResult.title,
          body: contentResult.content,  // Note: 'body' not 'content' for database
          excerpt: contentResult.excerpt || this.generateExcerpt(contentResult.content),
          metaDescription:
            contentResult.metaDescription ||
            this.generateMetaDescription(contentResult.title, contentResult.content),
          metaTitle: contentResult.metaTitle || contentResult.title,
          aiModel: AI_MODELS[request.aiProvider].model,
          seoKeywords: contentResult.keywords || request.keywords,
          seoScore: Math.max(1, Math.min(100, analysisResult.seoScore)),
          readabilityScore: Math.max(1, Math.min(100, analysisResult.readabilityScore)),
          brandVoiceScore: Math.max(1, Math.min(100, analysisResult.brandVoiceScore)),
          eatCompliance: request.eatCompliance || false,
          tokensUsed: contentTokens,
          costUsd: Math.round(totalCostUsd * 100), // Convert to cents for storage
          status: 'draft',
          hasImages: images.length > 0,
          imageCount: images.length,
          imageCostCents: Math.round(totalImageCost * 100)
        };

        console.log(`üíæ Saving content to database...`);
        const savedContent = await storage.createContent(contentToSave);
        
        // CRITICAL: Get the real database ID from the saved content
        savedContentId = savedContent.id;
        contentId = savedContentId; // Update the outer contentId variable
        
        console.log(`‚úÖ Content saved with real database ID: ${savedContentId}`);
        
        // Verify we have a valid ID (should not start with 'temp-')
        if (!savedContentId || savedContentId.startsWith('temp-')) {
          throw new Error(`Invalid content ID received from database: ${savedContentId}. Content save may have failed.`);
        }

        // Handle auto-publishing if configured
        if (request.isAutoGenerated && request.autoScheduleId && request.autoPublish) {
          console.log(`üöÄ Processing auto-publishing for content ${savedContentId}...`);

          if (request.publishDelay === 0) {
            // Immediate publishing
            scheduledDate = new Date();

            try {
              await storage.createContentSchedule({
                contentId: savedContentId,  // Use the real database ID
                userId: request.userId,
                websiteId: request.websiteId,
                scheduled_date: scheduledDate,
                status: "publishing",
                title: contentResult.title,
                topic: request.topic,  // Add topic field (required by database)
                metadata: {
                  autoGenerated: true,
                  autoScheduleId: request.autoScheduleId,
                  publishedImmediately: true,
                  generatedAt: new Date(),
                },
              });

              const publishResult = await this.publishToWordPress(
                savedContentId,  // Use real ID
                request.websiteId,
                request.userId
              );

              if (publishResult.success) {
                published = true;
                publishedAt = new Date();

                // Update content status using the existing updateContent method
                await storage.updateContent(savedContentId, {
                  status: "published",
                  publishDate: publishedAt,
                  wordpressPostId: publishResult.postId,
                });

                // Update schedule status
                await storage.updateContentScheduleByContentId(savedContentId, {
                  status: "published",
                  published_at: publishedAt,
                });

                console.log(
                  `‚úÖ Content published immediately to WordPress (Post ID: ${publishResult.postId})`
                );
              } else {
                console.error(`‚ùå Failed to publish immediately: ${publishResult.error}`);

                await storage.updateContentScheduleByContentId(savedContentId, {
                  status: "failed",
                  error: publishResult.error,
                });
              }
            } catch (publishError: any) {
              console.error(`‚ùå Auto-publishing error: ${publishError.message}`);
            }
          } else if (request.publishDelay && request.publishDelay > 0) {
            // Delayed publishing
            scheduledDate = new Date();
            scheduledDate.setHours(scheduledDate.getHours() + request.publishDelay);
            scheduledForPublishing = true;

            try {
              await storage.createContentSchedule({
                contentId: savedContentId,  // Use real ID
                userId: request.userId,
                websiteId: request.websiteId,
                scheduled_date: scheduledDate,
                status: "scheduled",
                title: contentResult.title,
                topic: request.topic,  // Add topic field
                metadata: {
                  autoGenerated: true,
                  autoScheduleId: request.autoScheduleId,
                  publishDelay: request.publishDelay,
                  generatedAt: new Date(),
                },
              });

              console.log(`‚è∞ Content scheduled for publishing at ${scheduledDate.toISOString()}`);
            } catch (scheduleError: any) {
              console.error(`‚ùå Failed to create schedule entry: ${scheduleError.message}`);
            }
          }
        } else if (request.isAutoGenerated && !request.autoPublish) {
          // Auto-generated but not auto-publishing (save as draft)
          try {
            await storage.createContentSchedule({
              contentId: savedContentId,  // Use real ID
              userId: request.userId,
              websiteId: request.websiteId,
              scheduled_date: new Date(),
              status: "draft",
              title: contentResult.title,
              topic: request.topic,  // Add topic field
              metadata: {
                autoGenerated: true,
                autoScheduleId: request.autoScheduleId,
                isDraft: true,
                generatedAt: new Date(),
              },
            });

            console.log(`üìù Content saved as draft (auto-publish disabled)`);
          } catch (scheduleError: any) {
            console.error(`‚ùå Failed to create draft schedule entry: ${scheduleError.message}`);
          }
        }
      } catch (saveError: any) {
        console.error(`‚ùå Failed to save content to database: ${saveError.message}`);
        // Don't continue if we can't save the content
        throw new Error(`Content generation failed: Unable to save content - ${saveError.message}`);
      }

      // Step 9: Return complete result
      const result: ContentGenerationResultWithPublishing = {
        title: contentResult.title,
        content: contentResult.content,
        excerpt: contentResult.excerpt || this.generateExcerpt(contentResult.content),
        metaDescription:
          contentResult.metaDescription ||
          this.generateMetaDescription(contentResult.title, contentResult.content),
        metaTitle: contentResult.metaTitle || contentResult.title,
        keywords: contentResult.keywords || request.keywords,
        seoScore: Math.max(1, Math.min(100, analysisResult.seoScore)),
        readabilityScore: Math.max(1, Math.min(100, analysisResult.readabilityScore)),
        brandVoiceScore: Math.max(1, Math.min(100, analysisResult.brandVoiceScore)),
        eatCompliance: request.eatCompliance || false,
        tokensUsed: contentTokens,
        costUsd: Number(textCostUsd.toFixed(6)),
        aiProvider: request.aiProvider,
        qualityChecks,
        contentId: savedContentId,  // CRITICAL: Use the saved database ID
        published: published,
        scheduledForPublishing: scheduledForPublishing,
        publishedAt: publishedAt,
        scheduledDate: scheduledDate,
        totalCost: totalCostUsd.toFixed(6),
      };

      if (images.length > 0) {
        result.images = images.map((img) => ({
          url: img.cloudinaryUrl || img.url,
          filename: img.filename,
          altText: img.altText,
          prompt: img.prompt,
          cost: img.cost,
          cloudinaryUrl: img.cloudinaryUrl,
          cloudinaryPublicId: img.cloudinaryPublicId,
        }));
        result.totalImageCost = totalImageCost;
      }

      console.log(
        `‚úÖ Content generation completed successfully with ${request.aiProvider.toUpperCase()}${
          images.length > 0 ? ` + DALL-E (${images.length} images on Cloudinary)` : ""
        }${
          published
            ? " - PUBLISHED IMMEDIATELY"
            : scheduledForPublishing
            ? " - SCHEDULED FOR PUBLISHING"
            : ""
        }`
      );

      return result;
    } catch (error: any) {
      if (error instanceof AIProviderError || error instanceof AnalysisError) {
        throw error;
      }
      throw new Error(`Content generation failed: ${error.message}`);
    }
  }

  private async publishToWordPress(
    contentId: string,
    websiteId: string,
    userId: string
  ): Promise<{ success: boolean; postId?: string; error?: string }> {
    try {
      const content = await storage.getContent(contentId);
      if (!content) {
        return { success: false, error: "Content not found" };
      }

      const website = await storage.getUserWebsite(websiteId, userId);
      if (!website) {
        return { success: false, error: "Website not found" };
      }

      // TODO: Implement actual WordPress REST API call
      console.log("TODO: Implement WordPress API publishing");
      return {
        success: false,
        error: "WordPress API not yet implemented",
      };
    } catch (error: any) {
      console.error("WordPress publishing error:", error);
      return { success: false, error: error.message };
    }
  }

  private async performContentAnalysis(
    request: ContentAnalysisRequest
  ): Promise<ContentAnalysisResult> {
    let totalTokens = 0;
    let seoScore = 50;
    let readabilityScore = 50;
    let brandVoiceScore = 50;
   let keyType: 'user' | 'system' = 'system';

    try {
      console.log(`Starting content analysis with ${request.aiProvider.toUpperCase()}`);

      // Step 1: SEO Analysis
      const seoAnalysisResponse = await this.callAI(
        request.aiProvider,
        [
          {
            role: "system",
            content: `You are a technical SEO analyst. Analyze content for SEO effectiveness and return a numeric score.

ANALYSIS CRITERIA FOR SEO SCORE (1-100):

KEYWORD OPTIMIZATION (25 points):
- Primary keyword in title (5 points)
- Keywords in first paragraph (5 points)  
- Keywords in headings/subheadings (5 points)
- Natural keyword density 1-3% (5 points)
- Use of semantic/related keywords (5 points)

CONTENT STRUCTURE (25 points):
- Proper heading hierarchy (H1, H2, H3) (8 points)
- Logical content flow and organization (8 points)
- Use of lists, bullets for scannability (5 points)
- Appropriate content length for topic depth (4 points)

SEARCH INTENT ALIGNMENT (25 points):
- Content directly addresses search query (10 points)
- Provides comprehensive answer to user questions (8 points)
- Includes actionable information/next steps (7 points)

TECHNICAL SEO ELEMENTS (25 points):
- Optimized title tag under 60 characters (8 points)
- Meta description 150-160 characters with CTA (8 points)
- Internal linking opportunities mentioned (5 points)
- Content uniqueness and originality (4 points)

CRITICAL: Return ONLY a JSON object with numeric values: {"contentSeoScore": number, "analysis": "explanation"}`,
          },
          {
            role: "user",
            content: `Analyze this content for SEO:

TITLE: ${request.title}
CONTENT: ${request.content.substring(0, 3000)}${
              request.content.length > 3000 ? "... [TRUNCATED]" : ""
            }
TARGET KEYWORDS: ${request.keywords.join(", ")}
TARGET AUDIENCE: ${request.targetAudience || "General audience"}

Evaluate each criterion and provide a realistic score.`,
          },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.1,
        request.userId  // Pass userId for API key lookup
      );

      totalTokens += Math.max(1, seoAnalysisResponse.tokens);
      keyType = seoAnalysisResponse.keyType || 'system';

      // Parse SEO response
      try {
        let cleanContent = seoAnalysisResponse.content.trim();
        if (!cleanContent.startsWith("{")) {
          const start = cleanContent.indexOf("{");
          const end = cleanContent.lastIndexOf("}") + 1;
          if (start !== -1 && end > start) {
            cleanContent = cleanContent.substring(start, end);
          }
        }

        const seoAnalysis = JSON.parse(cleanContent);
        if (
          typeof seoAnalysis.contentSeoScore === "number" &&
          seoAnalysis.contentSeoScore >= 1 &&
          seoAnalysis.contentSeoScore <= 100
        ) {
          seoScore = Math.round(seoAnalysis.contentSeoScore);
          console.log(`‚úÖ SEO Score: ${seoScore}`);
        } else {
          console.warn(`‚ö†Ô∏è Invalid SEO score, using fallback`);
          seoScore = 55;
        }
      } catch (parseError) {
        console.error("‚ùå Failed to parse SEO analysis, using fallback score");
        seoScore = 50;
      }

      // Step 2: Readability Analysis
      const readabilityResponse = await this.callAI(
        request.aiProvider,
        [
          {
            role: "system",
            content: `You are a content readability expert. Analyze text complexity and return a numeric score 1-100.

READABILITY SCORING CRITERIA:

SENTENCE STRUCTURE (30 points):
- Average sentence length under 20 words (10 points)
- Variety in sentence length (8 points)
- Simple sentence structure (7 points)
- Minimal complex clauses (5 points)

VOCABULARY COMPLEXITY (25 points):
- Use of common, everyday words (10 points)
- Minimal jargon or well-explained terms (8 points)
- Active voice usage (7 points)

CONTENT ORGANIZATION (25 points):
- Clear paragraph structure (8 points)
- Effective transitions (8 points)
- Logical information flow (5 points)
- Proper formatting (4 points)

COMPREHENSION EASE (20 points):
- Understandable by target audience (8 points)
- Clear key points (6 points)
- Supporting examples (6 points)

CRITICAL: Return ONLY JSON: {"readabilityScore": number, "analysis": "explanation"}`,
          },
          {
            role: "user",
            content: `Analyze readability of this content:

${request.content.substring(0, 2000)}${request.content.length > 2000 ? "..." : ""}

Consider:
- Sentence complexity
- Word choice
- Paragraph structure
- Overall flow`,
          },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.1,
        request.userId  // Pass userId
      );

      totalTokens += Math.max(1, readabilityResponse.tokens);

      // Parse readability response
      try {
        let cleanContent = readabilityResponse.content.trim();
        if (!cleanContent.startsWith("{")) {
          const start = cleanContent.indexOf("{");
          const end = cleanContent.lastIndexOf("}") + 1;
          if (start !== -1 && end > start) {
            cleanContent = cleanContent.substring(start, end);
          }
        }

        const readabilityAnalysis = JSON.parse(cleanContent);
        if (
          typeof readabilityAnalysis.readabilityScore === "number" &&
          readabilityAnalysis.readabilityScore >= 1 &&
          readabilityAnalysis.readabilityScore <= 100
        ) {
          readabilityScore = Math.round(readabilityAnalysis.readabilityScore);
          console.log(`‚úÖ Readability Score: ${readabilityScore}`);
        } else {
          console.warn(`‚ö†Ô∏è Invalid readability score, using fallback`);
          readabilityScore = 60;
        }
      } catch (parseError) {
        console.error("‚ùå Failed to parse readability analysis, using fallback");
        readabilityScore = 60;
      }

      // Step 3: Brand Voice Analysis
      const brandVoiceResponse = await this.callAI(
        request.aiProvider,
        [
          {
            role: "system",
            content: `You are a brand voice analyst. Return a numeric score 1-100 for brand alignment.

BRAND VOICE SCORING CRITERIA:

TONE CONSISTENCY (30 points):
- Maintains specified tone throughout (15 points)
- Tone appropriate for target audience (8 points)
- Consistent voice personality (7 points)

VOCABULARY ALIGNMENT (25 points):
- Word choice matches brand voice (10 points)
- Consistent formality level (8 points)
- Industry-appropriate terminology (7 points)

BRAND PERSONALITY EXPRESSION (25 points):
- Reflects brand values (10 points)
- Writing style matches brand character (8 points)
- Appropriate authority level (7 points)

AUDIENCE APPROPRIATENESS (20 points):
- Language suitable for demographic (8 points)
- Content complexity matches audience (7 points)
- Cultural sensitivity (5 points)

CRITICAL: Return ONLY JSON: {"brandVoiceScore": number, "analysis": "evaluation"}`,
          },
          {
            role: "user",
            content: `Analyze brand voice alignment:

CONTENT: ${request.content.substring(0, 1500)}${
              request.content.length > 1500 ? "..." : ""
            }

BRAND REQUIREMENTS:
- Specified Tone: ${request.tone}
- Brand Voice: ${request.brandVoice || "Not specified - use tone as guidance"}
- Target Audience: ${request.targetAudience || "General audience"}
- Industry Context: Based on content topic

Evaluate how well the content aligns with these brand requirements.`,
          },
        ],
        request.aiProvider === "openai" ? { type: "json_object" } : undefined,
        0.1,
        request.userId  // Pass userId
      );

      totalTokens += Math.max(1, brandVoiceResponse.tokens);

      // Parse brand voice response
      try {
        let cleanContent = brandVoiceResponse.content.trim();
        if (!cleanContent.startsWith("{")) {
          const start = cleanContent.indexOf("{");
          const end = cleanContent.lastIndexOf("}") + 1;
          if (start !== -1 && end > start) {
            cleanContent = cleanContent.substring(start, end);
          }
        }

        const brandVoiceAnalysis = JSON.parse(cleanContent);
        if (
          typeof brandVoiceAnalysis.brandVoiceScore === "number" &&
          brandVoiceAnalysis.brandVoiceScore >= 1 &&
          brandVoiceAnalysis.brandVoiceScore <= 100
        ) {
          brandVoiceScore = Math.round(brandVoiceAnalysis.brandVoiceScore);
          console.log(`‚úÖ Brand Voice Score: ${brandVoiceScore}`);
        } else {
          console.warn(`‚ö†Ô∏è Invalid brand voice score, using fallback`);
          brandVoiceScore = 65;
        }
      } catch (parseError) {
        console.error("‚ùå Failed to parse brand voice analysis, using fallback");
        brandVoiceScore = 65;
      }

      console.log(
        `Content analysis completed - SEO: ${seoScore}%, Readability: ${readabilityScore}%, Brand Voice: ${brandVoiceScore}%`
      );

      // Calculate cost
      const pricing = AI_MODELS[request.aiProvider].pricing;
      const avgTokenCost = (pricing.input + pricing.output) / 2;
      const analysisCostUsd = (totalTokens * avgTokenCost) / 1000;

      // Track analysis usage
      try {
        await storage.trackAiUsage({
          websiteId: request.websiteId,
          userId: request.userId,
          model: AI_MODELS[request.aiProvider].model,
          tokensUsed: totalTokens,
          costUsd: Math.max(1, Math.round(analysisCostUsd * 100)),
          operation: "content_analysis",
          keyType: keyType
        });
      } catch (trackingError: any) {
        console.warn("AI usage tracking failed:", trackingError.message);
      }

      return {
        seoScore: seoScore,
        readabilityScore: readabilityScore,
        brandVoiceScore: brandVoiceScore,
        tokensUsed: totalTokens,
        costUsd: Number(analysisCostUsd.toFixed(6)),
        aiProvider: request.aiProvider,
      };
    } catch (error: any) {
      if (error instanceof AIProviderError || error instanceof AnalysisError) {
        throw error;
      }

      console.error("Analysis error, using fallback scores:", error.message);
      return {
        seoScore: 55,
        readabilityScore: 60,
        brandVoiceScore: 65,
        tokensUsed: Math.max(1, totalTokens || 100),
        costUsd: 0.001,
        aiProvider: request.aiProvider,
      };
    }
  }

  private generateQualityChecks(content: string, request: ContentGenerationRequest) {
    const wordCount = content.split(" ").length;
    const hasKeywords = request.keywords.some((keyword) =>
      content.toLowerCase().includes(keyword.toLowerCase())
    );
    const sentenceCount = content.split(".").length;
    const avgWordsPerSentence = wordCount / sentenceCount;

    const plagiarismRisk = content.length > 500 && hasKeywords ? "low" : "medium";
    const factualAccuracy =
      wordCount > 400 && hasKeywords && avgWordsPerSentence < 25
        ? "verified"
        : "needs_review";
    const brandAlignment =
      request.brandVoice && request.targetAudience ? "good" : "needs_improvement";

    return {
      plagiarismRisk: plagiarismRisk as const,
      factualAccuracy: factualAccuracy as const,
      brandAlignment: brandAlignment as const,
    };
  }

  private generateExcerpt(content: string): string {
    const firstParagraph = content.split("\n")[0] || content;
    return firstParagraph.length > 160
      ? firstParagraph.substring(0, 157) + "..."
      : firstParagraph;
  }

  private generateMetaDescription(title: string, content: string): string {
    const excerpt = this.generateExcerpt(content);
    return excerpt.length > 160 ? excerpt.substring(0, 157) + "..." : excerpt;
  }

  private buildContentPrompt(request: ContentGenerationRequest): string {
    // Your existing buildContentPrompt implementation remains the same
    const brandVoiceSection = request.brandVoice 
      ? `\nBrand personality: ${request.brandVoice} (weave this in naturally, don't force it)` 
      : "";
    
    const audienceSection = request.targetAudience 
      ? `\nWho's reading: ${request.targetAudience} (use their language, their problems, their world)` 
      : "";
    
    const eatSection = request.eatCompliance 
      ? `\nCredibility touches: Drop in real examples, mention specific tools you'd use, reference actual people/studies when it fits.` 
      : "";

    // Randomize opening approach for variety
    const openings = [
      "Start with a specific moment or observation",
      "Jump straight to solving their problem", 
      "Open with an unexpected angle or contradiction",
      "Begin mid-story and backfill naturally"
    ];
    const opening = openings[Math.floor(Math.random() * openings.length)];

    return `You need to write about "${request.topic}" and return a complete JSON response with all required fields for publishing.

CRITICAL: Your response MUST be valid JSON with ALL fields specified in the output structure at the end of this prompt.

CONTENT PARAMETERS:
Topic focus: ${request.topic}
Keywords to work in naturally: ${request.keywords.join(", ")} 
Target length: around ${request.wordCount} words (flex by 20% if needed)
Writing tone: ${request.tone}${brandVoiceSection}${audienceSection}${eatSection}

HUMAN AUTHENTICITY REQUIREMENTS:

Write like you're explaining this to someone you respect. ${opening}

Natural voice markers to include:
‚Ä¢ Use "I" occasionally - share real experience: "Last month I tried..." 
‚Ä¢ Conversational transitions: "Here's the thing..." / "But wait‚Äî" / "Okay, so..."
‚Ä¢ Specific details: "$47" not "affordable", "Tuesday morning" not "recently"
‚Ä¢ Name real tools: "I use Notion for..." not "a productivity tool"
‚Ä¢ Admit uncertainty: "I'm still figuring out..." / "This part's tricky..."
‚Ä¢ Add personality: mild opinions, preferences, even a pet peeve
‚Ä¢ Include rough numbers: "like 70%" instead of "72.4%"
‚Ä¢ Reference specific people/brands when relevant

Writing patterns:
‚Ä¢ Vary sentence length dramatically. Like this. Then follow with something longer that reflects how people actually explain things they care about.
‚Ä¢ Sometimes start with And or But
‚Ä¢ Use fragments for emphasis
‚Ä¢ Include asides (they add personality)
‚Ä¢ Let some paragraphs run long, others just a line
‚Ä¢ Don't always use perfect grammar in conversational parts

NEVER use these AI giveaways:
‚úó "Moreover" / "Furthermore" / "In essence" / "It's worth noting"
‚úó Three examples every single time
‚úó "In today's [adjective] world..."
‚úó Perfect structural symmetry
‚úó Generic examples like "Company X increased Y by Z%"

CONTENT STRUCTURE for the "content" field:
‚Ä¢ Use HTML tags: <h2>, <h3>, <p>, <ul>, <li>, <strong>, <em>
‚Ä¢ Start strong - no throat-clearing
‚Ä¢ Mix heading styles: Questions, statements, casual phrases
‚Ä¢ Vary section lengths based on what's interesting
‚Ä¢ Include 1-2 specific anecdotes or examples
‚Ä¢ Add an unexpected analogy from outside the industry
‚Ä¢ Don't summarize unless it genuinely helps

Example subheadings that feel human:
- "The part nobody talks about"
- "Why this actually matters"  
- "Here's where I messed up"
- "The surprisingly simple fix"

${request.seoOptimized ? `
NATURAL SEO (be subtle):
‚Ä¢ Work main keyword into title and first paragraph naturally
‚Ä¢ Use synonyms more than exact keywords
‚Ä¢ Include keyword in 1-2 subheadings max
‚Ä¢ Focus on actually answering the question
` : `
IGNORE SEO:
‚Ä¢ Just write naturally
‚Ä¢ Use whatever words feel right
`}

END NATURALLY:
Pick what fits: circle back to opening, give one specific action, ask a thought-provoking question, or just stop when done.

=== JSON OUTPUT STRUCTURE ===
Return your response as a valid JSON object with these EXACT field names:
{
  "title": "A compelling title under 60 characters that includes the primary keyword",
  "content": "The complete HTML-formatted article using <p>, <h2>, <h3>, <ul>, <li>, <strong>, <em> tags. Full article, not a summary.",
  "excerpt": "A 150-160 character excerpt that summarizes the key value",
  "metaDescription": "A 150-160 character meta description with a call-to-action",
  "metaTitle": "SEO-optimized title under 60 characters",
  "keywords": ["primary_keyword", "secondary_keyword", "related_term1", "related_term2", "related_term3"]
}

IMPORTANT: 
- Write naturally for the topic - adjust style accordingly
- All fields are required
- Content should be complete and ready to publish
- Minimum ${request.wordCount * 0.8} words
- Return ONLY the JSON object

Make the content feel like someone wrote it in one sitting, got excited about parts, maybe rambled slightly, but genuinely wanted to help.`;
  }

  async optimizeContent(
    content: string,
    keywords: string[],
    userId: string,
    aiProvider: AIProvider = "openai"
  ): Promise<{
    optimizedContent: string;
    suggestions: string[];
    seoScore: number;
  }> {
    // Implementation remains the same as original
    return {
      optimizedContent: content,
      suggestions: [],
      seoScore: 75,
    };
  }
}

export const aiService = new AIService();