



//server/services/imageMetadataServices.ts
import sharp from 'sharp';

// Type definitions
interface BaseImageOptions {
  contentId: string;
  optimizeForWeb?: boolean;
  maxWidth?: number;
  quality?: number;
}

interface ImageProcessingOptions extends BaseImageOptions {
  websiteName: string;
  contentMetadata?: {
    copyright?: string;
    author?: string;
    description?: string;
    isAIGenerated?: boolean;
    aiProvider?: string;
    aiModel?: string;
  };
}

interface ProcessingResult {
  processedImage: Buffer;
  originalSize: number;
  processedSize: number;
  compressionRatio: number;
  metadata?: {
    stripped?: boolean;
    added?: boolean;
    optimized?: boolean;
  };
}

export class ImageMetadataService {
  /**
   * Strip metadata from an image
   * @param imageBuffer - The input image buffer
   * @param keepColorProfile - Whether to preserve color profile information
   * @returns Processed image buffer with metadata stripped
   */
  async stripMetadata(
    imageBuffer: Buffer, 
    keepColorProfile: boolean = true
  ): Promise<Buffer> {
    try {
      let processedImage = sharp(imageBuffer);
      
      if (keepColorProfile) {
        // Keep only essential metadata for proper display
        const metadata = await sharp(imageBuffer).metadata();
        processedImage = processedImage.withMetadata({
          orientation: metadata.orientation,
          // Preserve color profile if present
          ...(metadata.icc && { icc: metadata.icc })
        });
      } else {
        // Strip all metadata
        processedImage = processedImage.withMetadata({});
      }
      
      return processedImage.toBuffer();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Failed to strip metadata: ${errorMessage}`);
    }
  }

  /**
   * Process AI-generated image with custom metadata and optimization
   * @param imageBuffer - The input image buffer
   * @param options - Processing options including metadata and optimization settings
   * @returns Processing result with buffer and statistics
   */
  async processAIGeneratedImage(
    imageBuffer: Buffer,
    options: ImageProcessingOptions
  ): Promise<ProcessingResult> {
    try {
      let image = sharp(imageBuffer);
      const processingMetadata: ProcessingResult['metadata'] = {};
      
      // First, strip existing metadata to start fresh
      image = image.withMetadata({});
      processingMetadata.stripped = true;
      
      // Build EXIF metadata object
      const exifData: any = {
        IFD0: {}
      };
      
      // Add copyright information
      if (options.contentMetadata?.copyright) {
        exifData.IFD0.Copyright = options.contentMetadata.copyright;
      } else if (options.websiteName) {
        exifData.IFD0.Copyright = `Â© ${new Date().getFullYear()} ${options.websiteName}`;
      }
      
      // Add author/artist information
      if (options.contentMetadata?.author) {
        exifData.IFD0.Artist = options.contentMetadata.author;
      }
      
      // Add description
      let description = '';
      if (options.contentMetadata?.description) {
        description = options.contentMetadata.description;
      } else {
        description = `Content ID: ${options.contentId}`;
        if (options.contentMetadata?.isAIGenerated) {
          description = `AI-generated content - ${description}`;
        }
      }
      if (description) {
        exifData.IFD0.ImageDescription = description;
      }
      
      // Add software information
      let software = 'AI Content Generator';
      if (options.contentMetadata?.aiModel) {
        software += ` - ${options.contentMetadata.aiModel}`;
      } else {
        software += ' - DALL-E 3'; // Default
      }
      exifData.IFD0.Software = software;
      
      // Add AI provider as a comment if specified
      if (options.contentMetadata?.aiProvider) {
        exifData.IFD0.XPComment = `Generated by ${options.contentMetadata.aiProvider}`;
      }
      
      // Apply the metadata
      image = image.withMetadata({
        exif: exifData
      });
      processingMetadata.added = true;
      
      // Optimize for web if requested
      if (options.optimizeForWeb) {
        const maxWidth = options.maxWidth || 1920;
        const quality = options.quality || 85;
        
        // Get current metadata to check dimensions
        const metadata = await sharp(imageBuffer).metadata();
        
        // Resize if needed (maintaining aspect ratio)
        if (metadata.width && metadata.width > maxWidth) {
          image = image.resize(maxWidth, null, {
            withoutEnlargement: true,
            fit: 'inside'
          });
        }
        
        // Convert to optimized JPEG
        image = image.jpeg({
          quality: quality,
          progressive: true,
          mozjpeg: true // Use mozjpeg encoder for better compression
        });
        
        processingMetadata.optimized = true;
      }
      
      // Generate the output buffer
      const outputBuffer = await image.toBuffer();
      
      return {
        processedImage: outputBuffer,
        originalSize: imageBuffer.length,
        processedSize: outputBuffer.length,
        compressionRatio: outputBuffer.length / imageBuffer.length,
        metadata: processingMetadata
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Image processing failed: ${errorMessage}`);
    }
  }

  /**
   * Add or update metadata without modifying the image data
   * @param imageBuffer - The input image buffer
   * @param metadata - Metadata to add or update
   * @returns Image buffer with updated metadata
   */
  async updateMetadataOnly(
    imageBuffer: Buffer,
    metadata: {
      copyright?: string;
      author?: string;
      description?: string;
      software?: string;
      comment?: string;
    }
  ): Promise<Buffer> {
    try {
      let image = sharp(imageBuffer);
      
      // Preserve existing image metadata while updating EXIF
      const existingMetadata = await image.metadata();
      
      const exifData: any = {
        IFD0: {}
      };
      
      if (metadata.copyright) {
        exifData.IFD0.Copyright = metadata.copyright;
      }
      if (metadata.author) {
        exifData.IFD0.Artist = metadata.author;
      }
      if (metadata.description) {
        exifData.IFD0.ImageDescription = metadata.description;
      }
      if (metadata.software) {
        exifData.IFD0.Software = metadata.software;
      }
      if (metadata.comment) {
        exifData.IFD0.XPComment = metadata.comment;
      }
      
      image = image.withMetadata({
        orientation: existingMetadata.orientation,
        exif: exifData
      });
      
      return image.toBuffer();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Failed to update metadata: ${errorMessage}`);
    }
  }

  /**
   * Get metadata from an image
   * @param imageBuffer - The input image buffer
   * @returns Metadata object
   */
  async getMetadata(imageBuffer: Buffer): Promise<sharp.Metadata> {
    try {
      return await sharp(imageBuffer).metadata();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Failed to read metadata: ${errorMessage}`);
    }
  }

  /**
   * Validate if an image buffer is valid
   * @param imageBuffer - The input image buffer
   * @returns Boolean indicating if the image is valid
   */
  async validateImage(imageBuffer: Buffer): Promise<boolean> {
    try {
      const metadata = await sharp(imageBuffer).metadata();
      return !!(metadata.width && metadata.height);
    } catch {
      return false;
    }
  }
}

// Export singleton instance for backward compatibility
export default new ImageMetadataService();